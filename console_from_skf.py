# -*- coding: utf-8 -*-
"""Console.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hJ3MX6MLBrYg1ryXbdQ_BNaUBgIZ6ivD
"""

#first program
print("Hello world!!!")
print("#hello hash")



#variables
name = 'John'
age = 20
new_patient = True

print(name, " ", age, " ", new_patient)

#user input
name = input("Enter your name: ")
print("Hello ", name)

#type conversion
birth_year = int(input("Enter your birth year: "))
recent_year = 2022
age = recent_year - birth_year
print("Your age: ", age)

#calculator
first = float(input("Enter first num: "))
second = float(input("Enter second num: "))
sum = first + second
print("Sum: " + str(sum))

#object methods
course = "Python for Beginners"
print(course.upper())
print(course.lower())
print(course.find('f'))
print(course.replace("for", "4"))
print("Python" in course)

#comparison operator
com = 3<2
print(com)
com = 3==2
print(com)
com = 3!=2
print(com)
#logical operator
com = 3!=2 and 3==2
print(com)
com = 3!=2 and 3>=2
print(com)
com = 3!=2 or 3==2
print(com)
com = 3!=2 and 3==2
com = not com
print(com)

#control statements
temparature = int(input("Temp: "))
if temparature > 30:
  print("It's a hot day")
  print("Drink plenty of water")
elif temparature >= 25:
  print("It's a room temparature")
else:
  print("Temparature is not counted")

#loop
i=1
while i<= 5:
  print(i * '#')
  i+=1

#list
names = ["A", "B", "C", "D", "E"]
names[0] = "L"
print(names)
print(names[0])
print(names[-1]) #print the element from the ending
print(names[0:3])

#list method
names.append("J")
print(names)

print(len(names))

names.insert(3, "M")
print(names)

names.remove("M")
print(names)

names.clear()
print(names)

print("D" in names)

#for loop with list
names = ["A", "B", "C", "D", "E"]
for n in names:
  print(n)

#range function
number = range(5)
for n in number:
  print(n)
print("-------")
for k in range(2, 10):
  print(k)

# tuple
num = (1, 3, 5)
print(len(num))

#fibonacci
n=10
n1=0
n2=1
nextNum = n1+n2
print(n1)
print(n2)

for i in range(3, n+1):
  print(nextNum) 
  n1 = n2
  n2 = nextNum
  nextNum = n1 + n2

#factorial
f = 3
mul = 1
for i in range(1, f+1):
  mul *= i

print(mul)

#insertion sorting
li = [4, 3, 1, 5, 9]
for i in range(len(li)):
  temp = li[i]
  j = i-1
  while (j>=0 and li[j] > temp):
    li[j+1] = li[j]
    j-=1
  li[j+1] = temp

print(li)

#prime number approach-1
n = 10
p = [2]
for i in range(3, n+1):
  pri = False
  for j in range(2, i):
    if(i%j == 0):
      pri = True
  if(not pri):
    p.append(i)

print(p)

#prime number approach-2
n = int(input("Enter a number: "))
k = int(n/2)

if(n == 2):
  print("Prime num")
elif(n>2):
  pri = False
  for j in range(2, k+1):
    if(n%j == 0):
      pri = True
      break
  if(not pri):
    print("Prime num")
  else:
    print("Not Prime num")
else:
  print("Not Prime num")

#stack and queue
stack = ['hello', 'world', 'best']
stack.append('wishes') #pushing element
print(stack)
print(stack.pop()) #poping element
print(stack)

queue = ['lion', 'tiger', 'panther']
queue.append('jaguar') #enque
print(queue)
print(queue.pop(0)) #deque
print(queue)

#dfs
graph = {
    '0': ['1', '3'],
    '1': ['3', '2', '5', '6'],
    '2': ['3', '1', '5', '4'],
    '3': ['1', '2', '4'],
    '4': ['3', '2', '6'],
    '5': ['1', '2'],
    '6': ['1', '4']
}
visited = set()
def dfs(graph, visited, node):
  if node not in visited:
    print(node)
    visited.add(node)
    for adjacent in graph[node]:
      dfs(graph, visited, adjacent)

print("Graph in depth first search: ")
dfs(graph, visited, '0')

#even, odd, sort
l1 = [10, 247, 44, 73, 57, 9] 
l2 = [88, 22, 5, 2, 9, 0, 3]
lf = []

for l in l1: #picking even from l1
  if (l%2 == 0):
    lf.append(l)

for l in l2: #picking even from l1
  if (l%2 == 1):
    lf.append(l)

print(lf)

for i in range(len(lf)):
  temp = lf[i]
  j = i-1
  while (j>=0 and lf[j] > temp):
    lf[j+1] = lf[j]
    j-=1
  lf[j+1] = temp

print(lf)

list1=[10,20,23,11,17]

list2=[13,43,24,36,12]

list3 = [] #list had to be declared 

for i in list1: 

  if(i%2 == 0):

    list3.append(i)



for i in list2: 

  if(i%2 != 0):

    list3.append(i)

def st(l):

  for i in range(1,len(l)):

    temp=l[i]

    j=i-1

    while j>=0 and temp<l[j]:

      l[j+1]=l[j]

      j=j-1

      l[j+1]=temp   

st(list3)

print("The elements are: ")

print(list3)

#bfs
graph = {
  '0' : ['2','1'],
  '1' : ['2'],
  '2' : ['0', '3'],
  '3' : ['3']
}

visited = [] 
queue = []    

def bfs(visited, graph, node):
  visited.append(node)
  queue.append(node)

  while queue:
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

bfs(visited, graph, '2')

#plot
import matplotlib.pyplot as p
x = [k for k in range(0, 55)]
y = [k*3 for k in x]

print(x)
print(y)

p.plot(x, y)

p.xlabel("x - axis")
p.ylabel("y - axis")
p.title("x vs y graph")

#plot
import matplotlib.pyplot as p

p.axis([1, 3, 1, 4])

x = [1, 2, 3]
y = [2, 4, 1]

p.plot(x, y)

#gcd
n1 = int(input("Enter the value-1: "))
n2 = int(input("Enter the value-2: "))
gcd = 0

if(n1 < n2):
  temp = n2
  n2 = n1
  n1 = temp

for k in range(1, n2+1):
  if(n2%k == 0 and n1%k == 0):
    gcd = k

print(gcd)

#harmonic series
sum = 0
n = int(input("Enter a value: "))
for k in range(1, n+1):
  sum += 1/k
  if(k == n):
    print("1/"+str(k))
    break
  print("1/"+str(k), end=" + ")

print()
print(sum)

#gcd with lib
import math as m

k =m.gcd(10, 20)
print(k)

# define the gcd value
from functools import reduce
from math import *

n = int(input("Enter the number: "))
v = []
for i in range(n):
  x = int(input("Enter the number "+str(i+1)+": "))
  v.append(x)
g = reduce(gcd, v)

print(g)

import random
    
class Agent:
    def __init__(self):
        def program(percept):abstract
        self.program=program

loc_A,loc_B,loc_C,loc_D='A','B','C','D'


class reflexVaccumAgent(Agent):
    def __init__(self):
        Agent.__init__(self)

        action=' '

        def program(percept):
            location=percept[0]
            status=percept[1]
            if status=='Dirty': action= 'Suck'
            elif location==loc_A: action= 'Right'
            elif location==loc_B: action= 'Down'
            elif location==loc_C: action= 'Left'
            elif location==loc_D: action= 'Up'
            

            percept=(location,status)
            print('Agent perceives %s and does %s' %(percept,action))
            return action
            
        self.program=program

        
class vaccumEnvironment():

    def __init__(self):
        self.status={ loc_A:random.choice(['Clean','Dirty']),
                      loc_B:random.choice(['Clean','Dirty']),
                      loc_C:random.choice(['Clean','Dirty']),
                      loc_D:random.choice(['Clean','Dirty'])
                      
                      }
    def add_object(self,object,location=None):
        object.location=location or self.default_location(object)

    def default_location(self,object):
        return random.choice([loc_A,loc_B,loc_C,loc_D])

    def percept(self,agent):
        return (agent.location,self.status[agent.location])

    def execute_action(self,agent,action):
        if action=='Right': agent.location=loc_B
        elif action=='Down': agent.location=loc_C
        elif action=='Left': agent.location=loc_D
        elif action=='Up': agent.location=loc_D
        elif action=='Suck':
            #if self.status[agent.location]=='Dirty'
            self.status[agent.location]='Clean'

      
Ragent=reflexVaccumAgent()
env=vaccumEnvironment()
env.add_object(Ragent)


for steps in range(5):
    print(env.percept(Ragent))
    action=Ragent.program(env.percept(Ragent))
    env.execute_action(Ragent,action)

class NumPyramid:
  def __init__(self, n):
    self.n = n
  def PrintMyNum(self):
    print('number: ', self.n)

k = NumPyramid(10)
k.PrintMyNum()

#number triangle
class NumPyramid:
  def __init__(self, n):
    self.n = n
  def PrintNumPyramid(self):
    for x in range(self.n):
      for y in range(x+1):
        print(y+1, end=' ')
      print()

k = NumPyramid(5)
k.PrintNumPyramid()

# * pyramid
class NumPyramid:
  def __init__(self, n):
    self.n = n
  def PrintNumPyramid(self):
    m = self.n
    for x in range(self.n):
      for y in range(m):
        print(end=' ')
      m -= 1
      for y in range(x+1):
        print("*", end=' ')
      print()

k = NumPyramid(5)
k.PrintNumPyramid()

# reverse number triangle
class NumPyramid:
  def __init__(self, n):
    self.n = n
  def PrintNumPyramid(self):
    x = self.n
    while(x>0):
      y = self.n
      while(y>self.n-x):
        print(y, end=' ')
        y-=1
      x-=1
      print()

k = NumPyramid(5)
k.PrintNumPyramid()

# right side * pyramid
class NumPyramid:
  def __init__(self, n):
    self.n = n
  def PrintNumPyramid(self):
    m = self.n
    for x in range(self.n):
      for y in range(m):
        print(end=' ')
      m -= 1
      for y in range(x+1):
        print("*", end='')
      print()

k = NumPyramid(5)
k.PrintNumPyramid()

#simple relex agent implementation

import random as r
#creating environment
class Environment():
  def __init__(self):
    self.locationCondition = {'A':1, 'B':1}

    #randomize location condition 0 -> dirty & 1 -> clean
    self.locationCondition['A'] = r.randint(0, 1)
    self.locationCondition['B'] = r.randint(0, 1)

#testing-1:
#env = Environment()
#print(env.locationCondition)

#creating agent
class SimpleReflexAgent(Environment):
  def __init__(self, Environment):
    vacPos = r.randint(0, 1) #set a postion for vacuum; 0 for A & 1 for B

    if vacPos == 0:
      #set A
      if Environment.locationCondition['A'] == 0:
        print("A -> dirty", end=' ')
        Environment.locationCondition['A'] = 1
        print("A -> clean")
      elif Environment.locationCondition['A'] == 1:
        print("A -> clean", end=' ')
        print("A -> B")
    
    elif vacPos == 1:
      # set B
      if Environment.locationCondition['B'] == 0:
        print("B -> dirty", end=' ')
        Environment.locationCondition['B'] = 1
        print("B -> clean")
      elif Environment.locationCondition['B'] == 1:
        print("B -> clean", end=' ')
        print("B -> A")
  

theEnv = Environment()
theAgent = SimpleReflexAgent(theEnv)

#simple reflex agent
import random as r

class Environment():
  def __init__(self):
    self.state = {
        'A': 'clean',
        'B': 'clean'
    }
    self.state['A'] = r.choice(['clean', 'dirty'])
    self.state['B'] = r.choice(['clean', 'dirty'])

class reflexAgent():
  def __init__(self, env):
    self.env = env

    if self.env.state['A'] == 'clean':
      print('[A, clean] -> MOVE RIGHT')
    elif self.env.state['A'] == 'dirty':
      print('[A, dirty] -> SUCK -> [A, clean]')
    if self.env.state['B'] == 'clean':
      print('[B, clean] -> MOVE LEFT')
    elif self.env.state['B'] == 'dirty':
      print('[B, dirty] -> SUCK -> [B, clean]')
    print('\n')

for timeStep in range(5):
  theEnv = Environment()
  theAgent = reflexAgent(theEnv)

GRAPH = {'Arad' : {'Sibiu' : 140, 'Zerind' : 75, 'Timisoara' : 118},
           'Zerind' : {'Arad' : 75, 'Oradea' : 71},
           'Oradea' : {'Zerind' : 75, 'Sibiu' : 151},
           'Sibiu' : {'Arad' : 140, 'Oradea' : 151, 'Fagaras' : 99, 'Rimnicu' : 80},
           'Timisoara' : {'Arad' : 118, 'Lugoj' : 111 },
           'Lugoj' : {'Timisoara' : 111, 'Mahadia' : 70},
           'Mahadia' : {'Lugoj' : 70, 'Drobeta' : 75},
           'Drobeta' : {'Mahadia' : 75, 'Cariova' : 120},
           'Craiova':{'Drobeta':120,'Rimnicu':146, 'pitesti':138},
           'Rimnicu':{'sibiu':80,'Craioa':146,'Pitesti':97},
           'Fagaras':{'sibiu':99, 'Bucharest': 211},
           'pitesti':{'Rimnicu':97, 'Craiove':138, 'Bucharest': 101},
           'Bucharest':{'Fagaras':211, 'Pitesti':101, 'Giurgiu':90, 'Urziceni':85},
           'Giurgiu':{'Bucharest': 90},
           'Urziceni':{'Bucharest': 85,'Vaslui':142, 'Hirsova':98},
           'Hirsova':{'Urziceni': 98, 'Eforie': 86},
           'Eforie':{'Hirsova': 86},
           'Vaslui' : {'Iasi': 92, 'Urziceni' : 142},
           'Iasi' : {'Vaslui' : 92, 'Neamt' : 87},
           'Neamt' : {'Iasi' : 87}
}

print(GRAPH)



GRAPH = {
            'Arad': {'Sibiu': 140, 'Zerind': 75, 'Timisoara': 118},\
            'Zerind': {'Arad': 75, 'Oradea': 71},
            'Oradea': {'Zerind': 71, 'Sibiu': 151},
            'Sibiu': {'Arad': 140, 'Oradea': 151, 'Fagaras': 99, 'Rimnicu': 80},
            'Timisoara': {'Arad': 118, 'Lugoj': 111},
            'Lugoj': {'Timisoara': 111, 'Mehadia': 70},
            'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
            'Drobeta': {'Mehadia': 75, 'Craiova': 120},
            'Craiova': {'Drobeta': 120, 'Rimnicu': 146, 'Pitesti': 138},
            'Rimnicu': {'Sibiu': 80, 'Craiova': 146, 'Pitesti': 97},
            'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
            'Pitesti': {'Rimnicu': 97, 'Craiova': 138, 'Bucharest': 101},
            'Bucharest': {'Fagaras': 211, 'Pitesti': 101, 'Giurgiu': 90, 'Urziceni': 85},
            'Giurgiu': {'Bucharest': 90},
            'Urziceni': {'Bucharest': 85, 'Vaslui': 142, 'Hirsova': 98},
            'Hirsova': {'Urziceni': 98, 'Eforie': 86},
            'Eforie': {'Hirsova': 86},
            'Vaslui': {'Iasi': 92, 'Urziceni': 142},
            'Iasi': {'Vaslui': 92, 'Neamt': 87},
            'Neamt': {'Iasi': 87}
        }

def dfs_paths(source, destination, path=None):
    """All possible paths from source to destination using depth-first search
    :param source: Source city name
    :param destination: Destination city name
    :param path: Current traversed path (Default value = None)
    :yields: All possible paths from source to destination
    """
    if path is None:
        path = [source]
    if source == destination:
        yield path
    for next_node in set(GRAPH[source].keys()) - set(path):
        yield from dfs_paths(next_node, destination, path + [next_node])

def ucs(source, destination):
    """Cheapest path from source to destination using uniform cost search
    :param source: Source city name
    :param destination: Destination city name
    :returns: Cost and path for cheapest traversal
    """
    from queue import PriorityQueue
    priority_queue, visited = PriorityQueue(), {}
    priority_queue.put((0, source, [source]))
    visited[source] = 0
    while not priority_queue.empty():
        (cost, vertex, path) = priority_queue.get()
        if vertex == destination:
            return cost, path
        for next_node in GRAPH[vertex].keys():
            current_cost = cost + GRAPH[vertex][next_node]
            if not next_node in visited or visited[next_node] >= current_cost:
                visited[next_node] = current_cost
                priority_queue.put((current_cost, next_node, path + [next_node]))

def a_star(source, destination):
    """Optimal path from source to destination using straight line distance heuristic
    :param source: Source city name
    :param destination: Destination city name
    :returns: Heuristic value, cost and path for optimal traversal
    """
    # HERE THE STRAIGHT LINE DISTANCE VALUES ARE IN REFERENCE TO BUCHAREST AS THE DESTINATION
    straight_line = {
                        'Arad': 366,
                        'Zerind': 374,
                        'Oradea': 380,
                        'Sibiu': 253,
                        'Timisoara': 329,
                        'Lugoj': 244,
                        'Mehadia': 241,
                        'Drobeta': 242,
                        'Craiova': 160,
                        'Rimnicu': 193,
                        'Fagaras': 176,
                        'Pitesti': 100,
                        'Bucharest': 0,
                        'Giurgiu': 77,
                        'Urziceni': 80,
                        'Hirsova': 151,
                        'Eforie': 161,
                        'Vaslui': 199,
                        'Iasi': 226,
                        'Neamt': 234
                    }
    from queue import PriorityQueue
    priority_queue, visited = PriorityQueue(), {}
    priority_queue.put((straight_line[source], 0, source, [source]))
    visited[source] = straight_line[source]
    while not priority_queue.empty():
        (heuristic, cost, vertex, path) = priority_queue.get()
        if vertex == destination:
            return heuristic, cost, path
        for next_node in GRAPH[vertex].keys():
            current_cost = cost + GRAPH[vertex][next_node]
            heuristic = current_cost + straight_line[next_node]
            if not next_node in visited or visited[next_node] >= heuristic:
                visited[next_node] = heuristic
                priority_queue.put((heuristic, current_cost, next_node, path + [next_node]))

def main():
    """Main function"""
    print('ENTER SOURCE :', end=' ')
    source = input().strip()
    print('ENTER GOAL :', end=' ')
    goal = input().strip()
    if source not in GRAPH or goal not in GRAPH:
        print('ERROR: CITY DOES NOT EXIST.')
    else:
        print('\nALL POSSIBLE PATHS:')
        paths = dfs_paths(source, goal)
        for path in paths:
            print(' -> '.join(city for city in path))
        print('\nCHEAPEST PATH:')
        cost, cheapest_path = ucs(source, goal)
        print('PATH COST =', cost)
        print(' -> '.join(city for city in cheapest_path))
        print('\nOPTIMAL PATH:')
        heuristic, cost, optimal_path = a_star(source, goal)
        print('HEURISTIC =', heuristic)
        print('PATH COST =', cost)
        print(' -> '.join(city for city in optimal_path))

if __name__ == '__main__':
    main()

l = [1, 2, 3]
k = [j*4 for j in l]
print(l.index(3))
print(k)

tree = {'S': [['A', 1], ['B', 5], ['C', 8]],
        'A': [['S', 1], ['D', 3], ['E', 7], ['G', 9]],
        'B': [['S', 5], ['G', 4]],
        'C': [['S', 8], ['G', 5]],
        'D': [['A', 3]],
        'E': [['A', 7]]}



heuristic = {'S': 8, 'A': 8, 'B': 4, 'C': 3, 'D': 5000, 'E': 5000, 'G': 0}


cost = {'S': 0}             


def AStarSearch():
    global tree, heuristic
    closed = []             
    opened = [['S', 8]]    

    '''find the visited nodes'''
    while True:
        fn = [i[1] for i in opened]     
        chosen_index = fn.index(min(fn))
        node = opened[chosen_index][0]  
        closed.append(opened[chosen_index])
        del opened[chosen_index]
        if closed[-1][0] == 'G':        
            break
        for item in tree[node]:
            if item[0] in [closed_item[0] for closed_item in closed]:
                continue
            cost.update({item[0]: cost[node] + item[1]})           
            fn_node = cost[node] + heuristic[item[0]] + item[1]     
            temp = [item[0], fn_node]
            opened.append(temp)                                     

    '''find optimal sequence'''
    trace_node = 'G'                        
    optimal_sequence = ['G']                
    for i in range(len(closed)-2, -1, -1):
        check_node = closed[i][0]           
        if trace_node in [children[0] for children in tree[check_node]]:
            children_costs = [temp[1] for temp in tree[check_node]]
            children_nodes = [temp[0] for temp in tree[check_node]]

            '''check whether h(s) + g(s) = f(s). If so, append current node to optimal sequence
            change the correct optimal tracing node to current node'''
            if cost[check_node] + children_costs[children_nodes.index(trace_node)] == cost[trace_node]:
                optimal_sequence.append(check_node)
                trace_node = check_node
    optimal_sequence.reverse()             

    return closed, optimal_sequence


if __name__ == '__main__':
    visited_nodes, optimal_nodes = AStarSearch()
    print('visited nodes: ' + str(visited_nodes))
    print('optimal nodes sequence: ' + str(optimal_nodes))

tree = {'a': [['b', 1], ['c', 1], ['d', 1]],
        'b': [['a', 1]],
        'c': [['a', 1], ['e', 2], ['f', 2], ['g', 2]],
        'd': [['a', 1]],
        'e': [['h', 3], ['i', 3], ['c', 2]],
        'f': [['c', 2], ['j', 4], ['k', 4]],
        'g': [['c', 2]],
        'h': [['e', 3]],
        'i': [['e', 3]],
        'j': [['f', 4], ['l', 5]],
        'k': [['f', 4]],
        'l': [['j', 5], ['n', 6]],
        'G': [['l', 6]],
        'n': [['l', 6]]}



heuristic = {'a': 4, 'b': 5, 'c': 3, 'd': 5, 'e': 3, 'f': 3, 'g': 4, 'h': 3, 'i': 4, 'j': 2, 'k': 4, 'l': 1, 'G': 0, 'n': 2,}


cost = {'a': 0} 


def AStarSearch():
    global tree, heuristic
    closed = []             # closed nodes
    opened = [['a', 4]]     # opened nodes

    '''find the visited nodes'''
    while True:
        fn = [i[1] for i in opened]     # fn = f(n) = g(n) + h(n)
        chosen_index = fn.index(min(fn))
        node = opened[chosen_index][0]  # current node
        closed.append(opened[chosen_index])
        del opened[chosen_index]
        if closed[-1][0] == 'G':        # break the loop if node G has been found
            break
        for item in tree[node]:
            if item[0] in [closed_item[0] for closed_item in closed]:
                continue
            cost.update({item[0]: cost[node] + item[1]})            # add nodes to cost dictionary
            fn_node = cost[node] + heuristic[item[0]] + item[1]     # calculate f(n) of current node
            temp = [item[0], fn_node]
            opened.append(temp)                                     # store f(n) of current node in array opened

    '''find optimal sequence'''
    trace_node = 'G'                        # correct optimal tracing node, initialize as node G
    optimal_sequence = ['G']                # optimal node sequence
    for i in range(len(closed)-2, -1, -1):
        check_node = closed[i][0]           # current node
        if trace_node in [children[0] for children in tree[check_node]]:
            children_costs = [temp[1] for temp in tree[check_node]]
            children_nodes = [temp[0] for temp in tree[check_node]]

            '''check whether h(s) + g(s) = f(s). If so, append current node to optimal sequence
            change the correct optimal tracing node to current node'''
            if cost[check_node] + children_costs[children_nodes.index(trace_node)] == cost[trace_node]:
                optimal_sequence.append(check_node)
                trace_node = check_node
    optimal_sequence.reverse()              # reverse the optimal sequence

    return closed, optimal_sequence


if __name__ == '__main__':
    visited_nodes, optimal_nodes = AStarSearch()
    print('visited nodes: ' + str(visited_nodes))
    print('optimal nodes sequence: ' + str(optimal_nodes))

import random


POPULATION_SIZE = 100

GENES = '''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP
QRSTUVWXYZ 1234567890, .-;:_!"#%&/()=?@${[]}'''


TARGET = "Thoughs can never be changed"

class Individual(object):
	'''
	Class representing individual in population
	'''
	def __init__(self, chromosome):
		self.chromosome = chromosome
		self.fitness = self.cal_fitness()

	@classmethod
	def mutated_genes(self):
		'''
		create random genes for mutation
		'''
		global GENES
		gene = random.choice(GENES)
		return gene

	@classmethod
	def create_gnome(self):
		'''
		create chromosome or string of genes
		'''
		global TARGET
		gnome_len = len(TARGET)
		return [self.mutated_genes() for _ in range(gnome_len)]

	def mate(self, par2):
		'''
		Perform mating and produce new offspring
		'''


		child_chromosome = []
		for gp1, gp2 in zip(self.chromosome, par2.chromosome):

			prob = random.random()

	
			if prob < 0.45:
				child_chromosome.append(gp1)

		
			elif prob < 0.90:
				child_chromosome.append(gp2)

			
			else:
				child_chromosome.append(self.mutated_genes())

		
		return Individual(child_chromosome)

	def cal_fitness(self):
		'''
		Calculate fitness score, it is the number of
		characters in string which differ from target
		string.
		'''
		global TARGET
		fitness = 0
		for gs, gt in zip(self.chromosome, TARGET):
			if gs != gt: fitness+= 1
		return fitness


def main():
	global POPULATION_SIZE


	generation = 1

	found = False
	population = []

	
	for _ in range(POPULATION_SIZE):
				gnome = Individual.create_gnome()
				population.append(Individual(gnome))

	while not found:

		population = sorted(population, key = lambda x:x.fitness)

	
		if population[0].fitness <= 0:
			found = True
			break

		
		new_generation = []

		
		s = int((10*POPULATION_SIZE)/100)
		new_generation.extend(population[:s])

	
		s = int((90*POPULATION_SIZE)/100)
		for _ in range(s):
			parent1 = random.choice(population[:50])
			parent2 = random.choice(population[:50])
			child = parent1.mate(parent2)
			new_generation.append(child)

		population = new_generation

		print("Generation: {}\tString: {}\tFitness: {}".\
			format(generation,
			"".join(population[0].chromosome),
			population[0].fitness))

		generation += 1

	
	print("Generation: {}\tString: {}\tFitness: {}".\
		format(generation,
		"".join(population[0].chromosome),
		population[0].fitness))

if __name__ == '__main__':
	main()

#initial fitness
from random import *
import math 

def evaluation_function(x):
  return int(15*x - x**2)

def dec_to_bin(d):
  return bin(d).replace("0b","")

def bin_to_str(b):
  if(len(str(b)) == 1):
    return ("000"+str(b))
  elif(len(str(b)) == 2):
    return ("00"+str(b))
  elif(len(str(b)) == 3):
    return ("0"+str(b))
  else:
    return str(b)

def bin_to_dec(b):
  return int(b, 2)

def crossing(b1, b2):
  k1 = list(b1)
  k2 = list(b2)

  t1 = k1[2:4]
  t2 = k2[2:4]

  k1[2] = t2[0]
  k1[3] = t2[1]

  k2[2] = t1[0]
  k2[3] = t1[1]

  s1 = s2 = '0b'

  for f in range(len(b1)):
    s1 += k1[f]
    s2 += k2[f]

  #s1.join(k1)
  #s2.join(k2)
  return [bin_to_dec(s1), bin_to_dec(s2)]



def crossover(genes):
  mutated_genes = {}
  genes_for_mutation = []
  for x in genes:
    genes_for_mutation.append(bin_to_str(dec_to_bin(x)))

  n = math.floor(len(genes)/2)

  k = 0
  for g in genes:
    if k>=n:
      break
    genes_for_mutation[k], genes_for_mutation[-(k+1)] = crossing(genes_for_mutation[k], genes_for_mutation[-(k+1)])
    k += 1
  
  
  for x in genes_for_mutation:
    mutated_genes.update({x: bin_to_str(dec_to_bin(x))})
    #print(x)


  # return mutated_genes
  # return [[x for x in mutated_genes], "Max->"+str(max([x for x in mutated_genes]))]
  return [x for x in mutated_genes]


def initial_fitness():
  population_size = 6
  possibility_rate_of_crossover = 0.7
  x = [] #initial genes
  
  for i in range(population_size):
    x.append(randint(0, 15))

  print(x)

  #print(crossover(x))

  number_of_genes_should_be_evaluated = int(len(x)*possibility_rate_of_crossover)
  #print(number_of_genes_should_be_evaluated)

  # for k in range(number_of_genes_should_be_evaluated):
  #   choromosome_fitness.append(evaluation_function(x[k]))  

  #before crossover
  choromosome_fitness = []
  # for k in range(number_of_genes_should_be_evaluated):
  #   choromosome_fitness.append(evaluation_function(x[k]))

  m = []
  for ppp in range(number_of_genes_should_be_evaluated):
    m.append(x[ppp])

  y = crossover(m)
  for k in range(len(y)):
    choromosome_fitness.append(evaluation_function(y[k]))
  

  print(choromosome_fitness)
  print(max(choromosome_fitness))
  print("#######")
  print()



for k in range(100):
  initial_fitness()
#print(bin_to_str(dec_to_bin(15)))

#print(crossing("1010", "0011"))
# print(bin_to_dec('10101'))

# f, a = [2, 3]
# print(f)
#crossover([10, 6, 3, 2])

#n queen problem... 

n = 4
space = [[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [1, 0, 0, 0]]

standard_space = [[0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]
print("Space: ")
for i in range(n):
  for j in range(n):
    print(space[i][j], end=" ")
  print()

print()
print()
print("Standard Space: ")
for i in range(n):
  for j in range(n):
    print(standard_space[i][j], end=" ")
  print()

def isSafe(graph, color):


	for i in range(4):
		for j in range(i + 1, 4):
			if (graph[i][j] and color[j] == color[i]):
				return False
	return True


def graphColoring(graph, m, i, color):
	if (i == 4):
		if (isSafe(graph, color)):
			printSolution(color)
			return True
		return False

	for j in range(1, m + 1):
		color[i] = j


		if (graphColoring(graph, m, i + 1, color)):
			return True
		color[i] = 0
	return False


def printSolution(color):
	print("Solution Exists:" " Following are the assigned colors ")
	for i in range(4):
		print(color[i],end=" ")

if __name__ == '__main__':

	# /* Create following graph and
	# test whether it is 3 colorable
	# (3)---(2)
	# | / |
	# | / |
	# | / |
	# (0)---(1)
	# */
	graph = [
		[ 0, 1, 1, 1 ],
		[ 1, 0, 1, 0 ],
		[ 1, 1, 0, 1 ],
		[ 1, 0, 1, 0 ],
	]
	m = 3 

	color = [0 for i in range(4)]

	if (not graphColoring(graph, m, 0, color)):
		print ("Solution does not exist")

color_countries = {}

colors = ['red', 'green', 'blue']

countries = ['WA', 'NT', 'SA', 'Q','NSW', 'V', 'T']

State = {
  'WA' : ['NT', 'SA'],
  'NT' : ['WA', 'Q' , 'SA'],
  'SA' : ['WA', 'NT','Q', 'NSW', 'V'],
  'Q' : ['NT','SA','NSW'],
  'NSW' : ['Q', 'SA', 'V'],
  'V' : ['NSW', 'SA'],
  'T' : []
}

def chk_countries(country , color):
    for neighbour in State.get(country): 
        colorOfNeighbour = color_countries.get(neighbour)
        if colorOfNeighbour == color:
            return False

    return True

def getColor(country):
    for color in colors:
        if chk_countries(country, color):
            return color

for country in countries:
        color_countries[country] = getColor(country)

print (color_countries)

from random import *
import math 

def evaluation_function(x):
  return int(x**2)

def dec_to_bin(d):
  return bin(d).replace("0b","")

def bin_to_str(b):
  if(len(str(b)) == 1):
    return ("0000"+str(b))
  elif(len(str(b)) == 2):
    return ("000"+str(b))
  elif(len(str(b)) == 3):
    return ("00"+str(b))
  elif(len(str(b)) == 4):
    return ("0"+str(b))
  else:
    return str(b)

def bin_to_dec(b):
  return int(b, 2)

def crossing(b1, b2):
  k1 = list(b1)
  k2 = list(b2)

  t1 = k1[2:4]
  t2 = k2[2:4]

  k1[2] = t2[0]
  k1[3] = t2[1]

  k2[2] = t1[0]
  k2[3] = t1[1]

  s1 = s2 = '0b'

  for f in range(len(b1)):
    s1 += k1[f]
    s2 += k2[f]

  return [bin_to_dec(s1), bin_to_dec(s2)]



def crossover(genes):
  mutated_genes = {}
  genes_for_mutation = []
  for x in genes:
    genes_for_mutation.append(bin_to_str(dec_to_bin(x)))

  n = math.floor(len(genes)/2)

  k = 0
  for g in genes:
    if k>=n:
      break
    genes_for_mutation[k], genes_for_mutation[-(k+1)] = crossing(genes_for_mutation[k], genes_for_mutation[-(k+1)])
    k += 1
  
  
  for x in genes_for_mutation:
    mutated_genes.update({x: bin_to_str(dec_to_bin(x))})

  return [x for x in mutated_genes]


def initial_fitness():
  population_size = 6
  possibility_rate_of_crossover = 0.7
  x = [] 
  
  for i in range(population_size):
    x.append(randint(0, 31))

  print(x)

 

  number_of_genes_should_be_evaluated = int(len(x)*possibility_rate_of_crossover)
 

  choromosome_fitness = []


  m = []
  for ppp in range(number_of_genes_should_be_evaluated):
    m.append(x[ppp])

  y = crossover(m)
  for k in range(len(y)):
    choromosome_fitness.append(evaluation_function(y[k]))
  

  print(choromosome_fitness)
  print(max(choromosome_fitness))
  print("   ")
  print()



for k in range(100):
  initial_fitness()

